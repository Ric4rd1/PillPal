const int CA1 = 21; // Input signal A form encoder 1.
const int CB1 = 19; // Input signal B from encoder 1.

const int CA2 = 32; // Input signal A from encoder 2.
const int CB2 = 35; // Input signal B from encoder 2.

const int MA1 = 12; // Input signal A from motor 1.
const int MB1 = 14; // Input signal B from motor 1.

const int MA2 = 4; // Input signal A from motor 2.
const int MB2 = 2; // Input signal B from motor 2.

const int PWM1 = 26; // Input signal pwm for motor 1. 
const int PWM2 = 27; // Input signal pwm for motor 2. 

volatile int  n1    = 0; // counts for encoder 1.
volatile int  n2    = 0; // counts for encoder 1.
volatile byte ant1  = 0; // previous encoder 1. state
volatile byte act1  = 0; // actual encoder 1. state 
volatile byte act2  = 0; // previous encoder 2. state
volatile byte ant2  = 0; // actual encoder 2. state

unsigned long lastTime = 0;  
unsigned long sampleTime = 100; 

const double pi =3.1416;
const double diameter = 7; // Wheel radius in cm

double P1 = 0; // Position in degrees motor 1
double P2 = 0; // Position in degrees motor2
double D1 = 0; // Motor 1 Distance moved in cm
double D2 = 0; // Motor 2 Distance moved in cm
double R = 937.2; // Resolution R = mH x s x r,
                  // mH = counts per motor rev (11),
                  // s = states generated by AB channels (4),
                  // r = gearBox reduction ratio (21.3)
void setup()
{
  Serial.begin(9600);

  // Encoder 1
  pinMode(CA1, INPUT);
  pinMode(CB1, INPUT);
  attachInterrupt(digitalPinToInterrupt(CA1), encoder1, CHANGE);
  attachInterrupt(digitalPinToInterrupt(CB1), encoder1, CHANGE);

  //Encoder 2
  pinMode(CA2, INPUT);
  pinMode(CB2, INPUT);
  attachInterrupt(digitalPinToInterrupt(CA2), encoder2, CHANGE);
  attachInterrupt(digitalPinToInterrupt(CB2), encoder2, CHANGE);

  //Motors
  pinMode(MA1, OUTPUT);
  pinMode(MB1, OUTPUT);
  pinMode(MA2, OUTPUT);
  pinMode(MB2, OUTPUT);
  // Speed control
  pinMode(PWM1, OUTPUT); 
  pinMode(PWM2, OUTPUT);

  setMotorSpeeds(200,200);

  digitalWrite(MA1, HIGH);
  digitalWrite(MB1, LOW);
  digitalWrite(MA2, HIGH);
  digitalWrite(MB2, LOW);
  
  Serial.println("Count: ");

}

void loop() {
  if (millis() - lastTime >= sampleTime || lastTime==0)
  {  // Se actualiza cada sampleTime (milisegundos)
      lastTime = millis();
      P1 = (n1*360.0)/R;
      P2 = (n2*360.0)/R;
      Serial.print("Posicion en grados Motor 1: ");Serial.println(P1);
      Serial.print("Posicion en grados Motor 2: ");Serial.println(P2);
      D1 = (P1/360)*pi*diameter;
      D2 = (P2/360)*pi*diameter;
      Serial.print("Distancia recorrida Motor 1: ");Serial.println(D1);
      Serial.print("Distancia recorrida Motor 2: ");Serial.println(D2);

   }
}

// Encoder precisi칩n cu치druple.
void encoder1(void)
{

  ant1=act1;
  
  if(digitalRead(CA1)) bitSet(act1,1); else bitClear(act1,1);            
  if(digitalRead(CB1)) bitSet(act1,0); else bitClear(act1,0);
  
  
  
  if(ant1 == 2 && act1 ==0) n1++;
  if(ant1 == 0 && act1 ==1) n1++;
  if(ant1 == 3 && act1 ==2) n1++;
  if(ant1 == 1 && act1 ==3) n1++;
  
  if(ant1 == 1 && act1 ==0) n1--;
  if(ant1 == 3 && act1 ==1) n1--;
  if(ant1 == 0 && act1 ==2) n1--;
  if(ant1 == 2 && act1 ==3) n1--;    
    

}

// Encoder precisi칩n cu치druple.
void encoder2(void)
{

  ant2=act2;
  
  if(digitalRead(CA2)) bitSet(act2,1); else bitClear(act2,1);            
  if(digitalRead(CB2)) bitSet(act2,0); else bitClear(act2,0);
  
  
  
  if(ant2 == 2 && act2 ==0) n2++;
  if(ant2 == 0 && act2 ==1) n2++;
  if(ant2 == 3 && act2 ==2) n2++;
  if(ant2 == 1 && act2 ==3) n2++;
  
  if(ant2 == 1 && act2 ==0) n2--;
  if(ant2 == 3 && act2 ==1) n2--;
  if(ant2 == 0 && act2 ==2) n2--;
  if(ant2 == 2 && act2 ==3) n2--;    
    

}

void setMotorSpeeds(int speed1, int speed2){
  analogWrite(PWM1, speed1);
  analogWrite(PWM2, speed2);
}